#!/bin/perl
#
# makeDist: Build a BackupPC distribution
#
# DESCRIPTION
#
#   This script should be run with no arguments to build a
#   distribution.  The $Version and $ReleaseDate should be
#   edited below to specify the version name and the release
#   date.  The distribution is createede in the sub-directory
#   dist.  The dsitribution is in the file name:
#
#           dist/BackupPC-$Version.tar.gz.
#
# AUTHOR
#   Craig Barratt <cbarratt@users.sourceforge.net>
#
# COPYRIGHT
#   Copyright (C) 2001-2003  Craig Barratt
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#========================================================================
#

use strict;
use File::Path;
use File::Copy;

umask(0022);

my $Version     = "2.1.0_CVS";
my $ReleaseDate = "8 Feb 2004";
my $DistDir     = "dist/BackupPC-$Version";

my @PerlSrc = qw(
    bin/BackupPC
    bin/BackupPC_archive
    bin/BackupPC_archiveHost
    bin/BackupPC_dump
    bin/BackupPC_link
    bin/BackupPC_nightly
    bin/BackupPC_restore
    bin/BackupPC_sendEmail
    bin/BackupPC_serverMesg
    bin/BackupPC_trashClean
    bin/BackupPC_tarExtract
    bin/BackupPC_tarCreate
    bin/BackupPC_compressPool
    bin/BackupPC_zipCreate
    bin/BackupPC_zcat
    lib/BackupPC/Attrib.pm
    lib/BackupPC/FileZIO.pm
    lib/BackupPC/Lib.pm
    lib/BackupPC/PoolWrite.pm
    lib/BackupPC/View.pm
    lib/BackupPC/CGI/AdminOptions.pm
    lib/BackupPC/CGI/Archive.pm
    lib/BackupPC/CGI/ArchiveInfo.pm
    lib/BackupPC/CGI/Browse.pm
    lib/BackupPC/CGI/DirHistory.pm
    lib/BackupPC/CGI/EmailSummary.pm
    lib/BackupPC/CGI/GeneralInfo.pm
    lib/BackupPC/CGI/HostInfo.pm
    lib/BackupPC/CGI/Lib.pm
    lib/BackupPC/CGI/LOGlist.pm
    lib/BackupPC/CGI/Queue.pm
    lib/BackupPC/CGI/ReloadServer.pm
    lib/BackupPC/CGI/RestoreFile.pm
    lib/BackupPC/CGI/RestoreInfo.pm
    lib/BackupPC/CGI/Restore.pm
    lib/BackupPC/CGI/StartServer.pm
    lib/BackupPC/CGI/StartStopBackup.pm
    lib/BackupPC/CGI/StopServer.pm
    lib/BackupPC/CGI/Summary.pm
    lib/BackupPC/CGI/View.pm
    lib/BackupPC/Lang/de.pm
    lib/BackupPC/Lang/en.pm
    lib/BackupPC/Lang/es.pm
    lib/BackupPC/Lang/fr.pm
    lib/BackupPC/Xfer/Archive.pm
    lib/BackupPC/Xfer/Smb.pm
    lib/BackupPC/Xfer/Tar.pm
    lib/BackupPC/Xfer/Rsync.pm
    lib/BackupPC/Xfer/RsyncFileIO.pm
    lib/BackupPC/Zip/FileMember.pm
    cgi-bin/BackupPC_Admin
);

#
# Check config parameters
#
my $ConfVars = {};
my $errCnt;

$errCnt += CheckConfigParams("conf/config.pl", $ConfVars, 0);
$ConfVars->{BackupPCUser} = 2;
$ConfVars->{CgiDir} = 2;
$ConfVars->{InstallDir} = 2;
$ConfVars->{CgiImageDir} = 2;
foreach my $file ( @PerlSrc ) {
    $errCnt += CheckConfigParams($file, $ConfVars, 1);
}
$errCnt += CheckLangUsage();
exit(1) if ( $errCnt );

$errCnt = 0;
foreach my $var ( sort(keys(%$ConfVars) ) ) {
    next if ( $ConfVars->{$var} >= 2 || $var =~ /^\$/ );
    printf("Unused config parameter $var\n");
    $errCnt++;
}
exit(1) if ( $errCnt );

rmtree($DistDir, 0, 0);
mkpath($DistDir, 0, 0777);

foreach my $dir ( qw(bin doc conf images init.d/src cgi-bin
		     lib/BackupPC/CGI
		     lib/BackupPC/Lang
		     lib/BackupPC/Xfer
		     lib/BackupPC/Zip
		) ) {
    mkpath("$DistDir/$dir", 0, 0777);
}

my %ConfName;
my $ConfPod = config2pod();
rmtree("doc", 0, 0);
mkpath("doc", 0, 0777);
InstallFile("doc-src/BackupPC.pod", "doc/BackupPC.pod");

use Pod::Html;
pod2html("doc/BackupPC.pod",
        "--backlink=Back to Top",
        "--header",
        "--title=BackupPC",
        "--outfile=doc/BackupPC.html");

foreach my $file ( (@PerlSrc,
	    <images/*>,
	    qw(
		conf/config.pl
		conf/hosts
		init.d/README
		init.d/src/debian-backuppc
		init.d/src/gentoo-backuppc
		init.d/src/gentoo-backuppc.conf
		init.d/src/linux-backuppc
		init.d/src/solaris-backuppc
		init.d/src/suse-backuppc
		doc/BackupPC.pod
		doc/BackupPC.html
		README
		LICENSE
		ChangeLog
		configure.pl
        )) ) {
    InstallFile("$file", "$DistDir/$file");
}
rmtree("doc", 0, 0);
system("cd dist ; tar zcf BackupPC-$Version.tar.gz BackupPC-$Version");
print("Distribution written to dist/BackupPC-$Version.tar.gz\n");
unlink("pod2htmd.x~~");
unlink("pod2htmi.x~~");

###########################################################################
# Subroutines
###########################################################################

sub InstallFile
{
    my($file, $dest) = @_;

    unlink($dest) if ( -d $dest );
    if ( $file =~ /\.gif/ ) {
        die("can't copy($file, $dest)\n") unless copy($file, $dest);
    } else {
	open(FILE, $file)   || die("can't open $file for reading\n");
	open(OUT, ">$dest") || die("can't open $dest for writing\n");
	binmode(FILE);
	binmode(OUT);
	while ( <FILE> ) {
	    s/^# *Version \d+\.\d+[\.\w]*, released \d+ \w+ \d{4}\.?/# Version __VERSION__, released __RELEASEDATE__./;
	    s/__VERSION__/$Version/g;
	    s/__RELEASEDATE__/$ReleaseDate/g;
	    if ( $file =~ /BackupPC\.html$/ && !/A NAME="item_%24Conf/ ) {
		s/\$Conf{([^}]*)}/
			defined($ConfName{$1})
			    ? "<A HREF=\"#$ConfName{$1}\">\$Conf{$1}<\/A>"
			    : "\$Conf{$1}"/eg;
	    }
	    if ( /__CONFIGPOD__/ ) {
		print OUT $ConfPod;
	    } elsif ( /^use lib ".*BackupPC\/lib";/
		    || /^use lib "\/home\/pcbackup\/install\/lib";/ ) {
		print OUT "use lib \"__INSTALLDIR__/lib\";\n";
	    } elsif ( $file =~ /Lib.pm/ && /(.*TopDir *=> .*)'.*',/ ) {
		print OUT "$1'__TOPDIR__',\n";
	    } elsif ( $file =~ /Lib.pm/ && /(.*Version *=> .*)'[\w\d\.]+',/ ) {
		print OUT "$1'$Version',\n";
	    } elsif ( $file =~ /Lib.pm/ && /(.*BinDir *=> .*)'.*',/ ) {
		print OUT "$1'__INSTALLDIR__',\n";
	    } elsif ( $file =~ /Lib.pm/ && /(.*LibDir *=> .*)'.*',/ ) {
		print OUT "$1'__INSTALLDIR__',\n";
	    } elsif ( $file =~ /BackupPC_Admin/ && /(my *\$installDir *= *)'.*'/ ) {
		print OUT "$1'__INSTALLDIR__/lib';\n";
	    } else {
		print OUT;
	    }
	}
	close(FILE);
	close(OUT);
    }
    if ( -x $file ) {
        chmod(0555, $dest);
    } else {
        chmod(0444, $dest);
    }
}

sub config2pod
{
    open(C, "conf/config.pl") || die("can't open conf/config.pl");
    binmode(C);
    my($str, $out, $getHdr, @conf);
    my $first = 1;
    while ( <C> ) {
        chomp;
        s/ +$//;
        if ( /^#########################/ ) {
            if ( $getHdr ) {
                $str =~ s/\n.*//sg;
                $out .= "=back\n\n" if ( !$first );
                $out .= "=head2 $str\n\n=over 4\n\n";
                $str = "";
                $first = 0;
            }
            $getHdr = !$getHdr;
            next;
        }
        if ( /^#/ ) {
            s/# ?//;
            next if ( $str eq "" && /^$/ );
            $str .= $_ . "\n";
            $str .= "\n" if ( $str =~ /examples?:\n$/i );
        } elsif ( /^\$Conf{([^}]*)/ ) {
            my $var = $1;
            s/  +/ /g;
            s/;\s*#.*/;/;
            if ( !s/\[$/[ ... ];/ && !s/<<'EOF'/.../ ) {
                s/([^;])\s*$/$1 .../;
            }
            push(@conf, $_);
            my $text = $_;
            $text =~ s/\s+/_/sg;
            $text =~ s{(\W)}{sprintf("%%%02X", ord($1) )}gxe;
            $text = substr($text, 0, 50);
            $ConfName{$var} = "item_$text";
        } elsif ( /^$/ ) {
            if ( $str ne "" && @conf ) {
                $out .= "=item " . join("\n\n=item ", @conf) . "\n\n";
                $out .= $str;
                $out .= "\n" if ( $str !~ /\n$/ );
            }
            $str = "";
            @conf = ();
        }
    }
    if ( $str ne "" && @conf ) {
        $out .= "=item " . join("\n\n=item ", @conf) . "\n\n";
        $out .= $str;
        $out .= "\n" if ( $str !~ /\n$/ );
    }
    $out .= "=back\n\n" if ( !$first );
    return $out;
}

sub CheckConfigParams
{
    my($file, $vars, $check) = @_;
    my $errors;

    open(F, $file) || die("can't open $file\n");
    binmode(F);
    if ( $check ) {
        while ( <F> ) {
            s/\$(self|bpc)->{Conf}{([^}\$]+)}/if ( !defined($vars->{$2}) ) {
                    print("Unexpected Conf var $2 in $file\n");
                    $errors++;
                } else {
                    $vars->{$2}++;
                }/eg;
            s/\$[Cc]onf(?:->)?{([^}\$]+)}/if ( !defined($vars->{$1}) ) {
                    print("Unexpected Conf var $1 in $file\n");
                    $errors++;
                } else {
                    $vars->{$1}++;
                }/eg;
            s/UserCommandRun\("([^"]*)"\)/if ( !defined($vars->{$1}) ) {
                    print("Unexpected Conf var $1 in $file\n");
                    $errors++;
                } else {
                    $vars->{$1}++;
                }/eg;
        }
    } else {
        while ( <F> ) {
            s/^[^#]*\$self->{Conf}{([^}]*)/$vars->{$1} = 1;/eg;
            s/^[^#]*\$Conf{([^}]*)/$vars->{$1} = 1;/eg;
        }
    }
    close(F);
    return $errors;
}

#
# Make sure that every lang variable in cgi-bin/BackupPC_Admin matches
# the strings in each lib/BackupPC/Lang/*.pm file.  This makes sure
# we didn't miss any translations in any of the languages.
#
sub CheckLangUsage
{
    my $errors;
    my $vars = {};

    foreach my $file ( (
		qw(cgi-bin/BackupPC_Admin bin/BackupPC_sendEmail),
		<lib/BackupPC/CGI/*pm>
	    ) ) {
	open(F, $file) || die("can't open $file");
	binmode(F);
	while ( <F> ) {
	    s/\$Lang->{([^}]*)}/$vars->{$1} = 1;/eg;
	}
	close(F);
    }
    # CB: disable other lang checks for now
    #
    # foreach my $f ( <lib/BackupPC/Lang/*.pm> ) {
    #
    foreach my $f ( <lib/BackupPC/Lang/en.pm> ) {
        my $done = {};
        open(F, $f) || die("can't open $f\n");
	binmode(F);
        while ( <F> ) {
            s/#.*//g;
            s/\$Lang{([^}]*)}/
		    my $var = $1;
		    next if ( $var =~ m{^(Reason_|Status_|backupType_)} );
                    if ( !defined($vars->{$var}) ) {
                        print("Unexpected Lang var $var in $f\n");
                        $errors++;
                    } else {
                        $done->{$var} = 1;
                    }/eg;
        }
        close(F);
        foreach my $v ( keys(%$vars) ) {
	    #
	    # skip "variables" with "$", since they are like expressions
	    #
	    next if ( $v =~ /\$/ );
            if ( !defined($done->{$v}) ) {
                print("Lang var $v missing from $f\n");
                $errors++;
            }
        }
    }
    return $errors;
}
