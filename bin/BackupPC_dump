#!/bin/perl -T
#============================================================= -*-perl-*-
#
# BackupPC_dump: Dump a single client.
#
# DESCRIPTION
#
#   Usage: BackupPC_dump [-i] [-f] [-d] [-e] [-v] <client>
#
#   Flags:
#
#     -i   Do an incremental dump, overriding any scheduling (but a full
#          dump will be done if no dumps have yet succeeded)
#
#     -f   Do a full dump, overriding any scheduling.
#
#     -d   Host is a DHCP pool address, and the client argument
#          just an IP address.  We lookup the NetBios name from
#          the IP address.
#
#     -e   Just do an dump expiry check for the client.  Don't do anything
#          else.  This is used periodically by BackupPC to make sure that
#          dhcp hosts have correctly expired old backups.  Without this,
#          dhcp hosts that are no longer on the network will not expire
#          old backups.
#
#     -v   verbose.  for manual usage: prints failure reasons in more detail.
#
#   BackupPC_dump is run periodically by BackupPC to backup $client.
#   The file $TopDir/pc/$client/backups is read to decide whether a
#   full or incremental backup needs to be run.  If no backup is
#   scheduled, or a ping to $client fails, then BackupPC_dump quits.
#
#   The backup is done using the selected XferMethod (smb, tar, rsync etc),
#   extracting the dump into $TopDir/pc/$client/new.  The xfer output is
#   put into $TopDir/pc/$client/XferLOG.
#
#   If the dump succeeds (based on parsing the output of the XferMethod):
#     - $TopDir/pc/$client/new is renamed to $TopDir/pc/$client/nnn, where
#           nnn is the next sequential dump number.
#     - $TopDir/pc/$client/XferLOG is renamed to $TopDir/pc/$client/XferLOG.nnn.
#     - $TopDir/pc/$client/backups is updated.
#
#   If the dump fails:
#     - $TopDir/pc/$client/new is moved to $TopDir/trash for later removal.
#     - $TopDir/pc/$client/XferLOG is renamed to $TopDir/pc/$client/XferLOG.bad
#           for later viewing.
#
#   BackupPC_dump communicates to BackupPC via printing to STDOUT.
#
# AUTHOR
#   Craig Barratt  <cbarratt@users.sourceforge.net>
#
# COPYRIGHT
#   Copyright (C) 2001  Craig Barratt
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#========================================================================
#
# Version 2.0.0beta2, released 13 Apr 2003.
#
# See http://backuppc.sourceforge.net.
#
#========================================================================

use strict;
use lib "/usr/local/BackupPC/lib";
use BackupPC::Lib;
use BackupPC::FileZIO;
use BackupPC::Xfer::Smb;
use BackupPC::Xfer::Tar;
use BackupPC::Xfer::Rsync;
use File::Path;
use Getopt::Std;

###########################################################################
# Initialize
###########################################################################

die("BackupPC::Lib->new failed\n") if ( !(my $bpc = BackupPC::Lib->new) );
my $TopDir = $bpc->TopDir();
my $BinDir = $bpc->BinDir();
my %Conf   = $bpc->Conf();
my $NeedPostCmd;
my $Hosts;

$bpc->ChildInit();

my %opts;
if ( !getopts("defiv", \%opts) || @ARGV != 1 ) {
    print("usage: $0 [-d] [-e] [-f] [-i] [-v] <client>\n");
    exit(1);
}
if ( $ARGV[0] !~ /^([\w\.\s-]+)$/ ) {
    print("$0: bad client name '$ARGV[0]'\n");
    exit(1);
}
my $client = $1;   # BackupPC's client name (might not be real host name)
my $hostIP;        # this is the IP address
my $host;          # this is the real host name

my($clientURI, $user);

$bpc->verbose(1) if ( $opts{v} );

if ( $opts{d} ) {
    #
    # The client name $client is simply a DHCP address.  We need to check
    # if there is any machine at this address, and if so, get the actual
    # host name via NetBios using nmblookup.
    #
    $hostIP = $client;
    if ( $bpc->CheckHostAlive($hostIP) < 0 ) {
	print("Exiting because CheckHostAlive($hostIP) failed\n")
			    if ( $opts{v} );
	exit(1);
    }
    if ( $Conf{NmbLookupCmd} eq "" ) {
	print("Exiting because \$Conf{NmbLookupCmd} is empty\n")
			    if ( $opts{v} );
	exit(1);
    }
    ($client, $user) = $bpc->NetBiosInfoGet($hostIP);
    if ( $client !~ /^([\w\.\s-]+)$/ ) {
	print("Exiting because NetBiosInfoGet($hostIP) returned '$client',"
	    . " an invalid host name\n")
			    if ( $opts{v} );
	exit(1)
    }
    $Hosts = $bpc->HostInfoRead($client);
    $host = $client;
} else {
    $Hosts = $bpc->HostInfoRead($client);
}
if ( !defined($Hosts->{$client}) ) {
    print("Exiting because host $client does not exist in the hosts file\n");
    exit(1)
}

my $Dir     = "$TopDir/pc/$client";
my @xferPid = ();
my $tarPid  = -1;

#
# Re-read config file, so we can include the PC-specific config
#
$clientURI = $bpc->uriEsc($client);
if ( defined(my $error = $bpc->ConfigRead($client)) ) {
    print("dump failed: Can't read PC's config file: $error\n");
    exit(1);
}
%Conf = $bpc->Conf();

#
# Catch various signals
#
$SIG{INT}  = \&catch_signal;
$SIG{ALRM} = \&catch_signal;
$SIG{TERM} = \&catch_signal;
$SIG{PIPE} = \&catch_signal;
$SIG{STOP} = \&catch_signal;
$SIG{TSTP} = \&catch_signal;
$SIG{TTIN} = \&catch_signal;
my $Pid = $$;

#
# Make sure we eventually timeout if there is no activity from
# the data transport program.
#
alarm($Conf{ClientTimeout});

mkpath($Dir, 0, 0777) if ( !-d $Dir );
if ( !-f "$Dir/LOCK" ) {
    open(LOCK, ">", "$Dir/LOCK") && close(LOCK);
}
open(LOG, ">>", "$Dir/LOG");
select(LOG); $| = 1; select(STDOUT);

#
# For the -e option we just expire backups and quit
#
if ( $opts{e} ) {
    BackupExpire($client);
    exit(0);
}

if ( !$opts{d} ) {
    #
    # In the non-DHCP case, make sure the host can be looked up
    # via NS, or otherwise find the IP address via NetBios.
    #
    if ( $Conf{ClientNameAlias} ne "" ) {
        $host = $Conf{ClientNameAlias};
    } else {
        $host = $client;
    }
    if ( !defined(gethostbyname($host)) ) {
        #
        # Ok, NS doesn't know about it.  Maybe it is a NetBios name
        # instead.
        #
	print("Name server doesn't know about $host; trying NetBios\n")
			if ( $opts{v} );
        if ( !defined($hostIP = $bpc->NetBiosHostIPFind($host)) ) {
	    print(LOG $bpc->timeStamp, "Can't find host $host via netbios\n");
            print("host not found\n");
            exit(1);
        }
    } else {
        $hostIP = $host;
    }
}

###########################################################################
# Figure out what to do and do it
###########################################################################

#
# See if we should skip this host during a certain range
# of times.
#
my $err = $bpc->ServerConnect($Conf{ServerHost}, $Conf{ServerPort});
if ( $err ne "" ) {
    print("Can't connect to server ($err)\n");
    print(LOG $bpc->timeStamp, "Can't connect to server ($err)\n");
    exit(1);
}
my $reply = $bpc->ServerMesg("status host($clientURI)");
$reply = $1 if ( $reply =~ /(.*)/s );
my(%StatusHost);
eval($reply);
$bpc->ServerDisconnect();

#
# For DHCP tell BackupPC which host this is
#
if ( $opts{d} ) {
    if ( $StatusHost{activeJob} ) {
        # oops, something is already running for this host
	print("Exiting because backup is already running for $client\n")
			if ( $opts{v} );
        exit(0);
    }
    print("DHCP $hostIP $clientURI\n");
}

my($needLink, @Backups, $type, $lastBkupNum, $lastFullBkupNum);
my $lastFull = 0;
my $lastIncr = 0;

if ( $Conf{FullPeriod} == -1 && !$opts{f} && !$opts{i}
        || $Conf{FullPeriod} == -2 ) {
    NothingToDo($needLink);
}

if ( !$opts{i} && !$opts{f} && $Conf{BlackoutGoodCnt} >= 0
             && $StatusHost{aliveCnt} >= $Conf{BlackoutGoodCnt} ) {
    my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    my($currHours) = $hour + $min / 60 + $sec / 3600;
    if ( $Conf{BlackoutHourBegin} <= $currHours
              && $currHours <= $Conf{BlackoutHourEnd}
              && grep($_ == $wday, @{$Conf{BlackoutWeekDays}}) ) {
#        print(LOG $bpc->timeStamp, "skipping because of blackout"
#                    . " (alive $StatusHost{aliveCnt} times)\n");
        NothingToDo($needLink);
    }
}

if ( !$opts{i} && !$opts{f} && $StatusHost{backoffTime} > time ) {
    printf(LOG "%sskipping because of user requested delay (%.1f hours left)",
                $bpc->timeStamp, ($StatusHost{backoffTime} - time) / 3600);
    NothingToDo($needLink);
}

#
# Now see if there are any old backups we should delete
#
BackupExpire($client);

#
# Read Backup information, and find times of the most recent full and
# incremental backups
#
@Backups = $bpc->BackupInfoRead($client);
for ( my $i = 0 ; $i < @Backups ; $i++ ) {
    $needLink = 1 if ( $Backups[$i]{nFilesNew} eq ""
                        || -f "$Dir/NewFileList.$Backups[$i]{num}" );
    $lastBkupNum = $Backups[$i]{num};
    if ( $Backups[$i]{type} eq "full" ) {
	if ( $lastFull < $Backups[$i]{startTime} ) {
	    $lastFull = $Backups[$i]{startTime};
	    $lastFullBkupNum = $Backups[$i]{num};
	}
    } else {
        $lastIncr = $Backups[$i]{startTime}
                if ( $lastIncr < $Backups[$i]{startTime} );
    }
}

#
# Decide whether we do nothing, or a full or incremental backup.
#
if ( @Backups == 0
        || $opts{f}
        || (!$opts{i} && (time - $lastFull > $Conf{FullPeriod} * 24*3600
            && time - $lastIncr > $Conf{IncrPeriod} * 24*3600)) ) {
    $type = "full";
} elsif ( $opts{i} || (time - $lastIncr > $Conf{IncrPeriod} * 24*3600
        && time - $lastFull > $Conf{IncrPeriod} * 24*3600) ) {
    $type = "incr";
} else {
    NothingToDo($needLink);
}

#
# Check if $host is alive
#
my $delay = $bpc->CheckHostAlive($hostIP);
if ( $delay < 0 ) {
    print(LOG $bpc->timeStamp, "no ping response\n");
    print("no ping response\n");
    print("link $clientURI\n") if ( $needLink );
    exit(1);
} elsif ( $delay > $Conf{PingMaxMsec} ) {
    printf(LOG "%sping too slow: %.4gmsec\n", $bpc->timeStamp, $delay);
    printf("ping too slow: %.4gmsec (threshold is %gmsec)\n",
                    $delay, $Conf{PingMaxMsec});
    print("link $clientURI\n") if ( $needLink );
    exit(1);
}

#
# Make sure it is really the machine we expect (only for fixed addresses,
# since we got the DHCP address above).
#
if ( !$opts{d} && (my $errMsg = CorrectHostCheck($hostIP, $host)) ) {
    print(LOG $bpc->timeStamp, "dump failed: $errMsg\n");
    print("dump failed: $errMsg\n");
    exit(1);
} elsif ( $opts{d} ) {
    print(LOG $bpc->timeStamp, "$host is dhcp $hostIP, user is $user\n");
}

#
# Get a clean directory $Dir/new
#
$bpc->RmTreeDefer("$TopDir/trash", "$Dir/new") if ( -d "$Dir/new" );

#
# Setup file extension for compression and open XferLOG output file
#
$Conf{CompressLevel} = 0 if ( !BackupPC::FileZIO->compOk );
my $fileExt = $Conf{CompressLevel} > 0 ? ".z" : "";
my $XferLOG = BackupPC::FileZIO->open("$Dir/XferLOG$fileExt", 1,
                                     $Conf{CompressLevel});
if ( !defined($XferLOG) ) {
    print(LOG $bpc->timeStamp, "dump failed: unable to open/create"
			     . " $Dir/XferLOG$fileExt\n");
    print("dump failed: unable to open/create $Dir/XferLOG$fileExt\n");
    exit(1);
}
$XferLOG->writeTeeStdout(1) if ( $opts{v} );
unlink("$Dir/NewFileList");
my $startTime = time();

my $tarErrs       = 0;
my $nFilesExist   = 0;
my $sizeExist     = 0;
my $sizeExistComp = 0;
my $nFilesTotal   = 0;
my $sizeTotal     = 0;
my($logMsg, %stat, $xfer, $ShareNames);
my $newFilesFH;

if ( $Conf{XferMethod} eq "tar" ) {
    $ShareNames = $Conf{TarShareName};
} elsif ( $Conf{XferMethod} eq "rsync" || $Conf{XferMethod} eq "rsyncd" ) {
    $ShareNames = $Conf{RsyncShareName};
} else {
    $ShareNames = $Conf{SmbShareName};
}

$ShareNames = [ $ShareNames ] unless ref($ShareNames) eq "ARRAY";

#
# Run an optional pre-dump command
#
UserCommandRun("DumpPreUserCmd");
$NeedPostCmd = 1;

#
# Now backup each of the shares
#
for my $shareName ( @$ShareNames ) {
    local(*RH, *WH);

    $stat{xferOK} = $stat{hostAbort} = undef;
    $stat{hostError} = $stat{lastOutputLine} = undef;
    if ( -d "$Dir/new/$shareName" ) {
        print(LOG $bpc->timeStamp,
                  "unexpected repeated share name $shareName skipped\n");
        next;
    }

    if ( $Conf{XferMethod} eq "tar" ) {
        #
        # Use tar (eg: tar/ssh) as the transport program.
        #
        $xfer = BackupPC::Xfer::Tar->new($bpc);
    } elsif ( $Conf{XferMethod} eq "rsync" || $Conf{XferMethod} eq "rsyncd" ) {
        #
        # Use rsync as the transport program.
        #
        if ( !defined($xfer = BackupPC::Xfer::Rsync->new($bpc)) ) {
            my $errStr = BackupPC::Xfer::Rsync::errStr;
            print(LOG $bpc->timeStamp, "dump failed: $errStr\n");
            print("dump failed: $errStr\n");
            UserCommandRun("DumpPostUserCmd") if ( $NeedPostCmd );
            exit(1);
        }
    } else {
        #
        # Default is to use smbclient (smb) as the transport program.
        #
        $xfer = BackupPC::Xfer::Smb->new($bpc);
    }

    my $useTar = $xfer->useTar;

    if ( $useTar ) {
	#
	# This xfer method outputs a tar format file, so we start a
	# BackupPC_tarExtract to extract the data.
	#
	# Create a pipe to connect the Xfer method to BackupPC_tarExtract
	# WH is the write handle for writing, provided to the transport
	# program, and RH is the other end of the pipe for reading,
	# provided to BackupPC_tarExtract.
	#
	pipe(RH, WH);

	#
	# fork a child for BackupPC_tarExtract.  TAR is a file handle
	# on which we (the parent) read the stdout & stderr from
	# BackupPC_tarExtract.
	#
	if ( !defined($tarPid = open(TAR, "-|")) ) {
	    print(LOG $bpc->timeStamp, "can't fork to run tar\n");
	    print("can't fork to run tar\n");
	    close(RH);
	    close(WH);
	    last;
	}
	if ( !$tarPid ) {
	    #
	    # This is the tar child.  Close the write end of the pipe,
	    # clone STDERR to STDOUT, clone STDIN from RH, and then
	    # exec BackupPC_tarExtract.
	    #
	    setpgrp 0,0;
	    close(WH);
	    close(STDERR);
	    open(STDERR, ">&STDOUT");
	    close(STDIN);
	    open(STDIN, "<&RH");
	    exec("$BinDir/BackupPC_tarExtract", $client, $shareName,
			 $Conf{CompressLevel});
	    print(LOG $bpc->timeStamp,
			"can't exec $BinDir/BackupPC_tarExtract\n");
	    exit(0);
	}
    } elsif ( !defined($newFilesFH) ) {
	#
	# We need to create the NewFileList output file
	#
	local(*NEW_FILES);
	open(NEW_FILES, ">", "$TopDir/pc/$client/NewFileList")
		     || die("can't open $TopDir/pc/$client/NewFileList");
	$newFilesFH = *NEW_FILES;
    }

    #
    # Run the transport program
    #
    $xfer->args({
        host        => $host,
        client      => $client,
        hostIP      => $hostIP,
        shareName   => $shareName,
        pipeRH      => *RH,
        pipeWH      => *WH,
        XferLOG     => $XferLOG,
	newFilesFH  => $newFilesFH,
        outDir      => $Dir,
        type        => $type,
        lastFull    => $lastFull,
	lastBkupNum => $lastBkupNum,
	lastFullBkupNum => $lastFullBkupNum,
	backups     => \@Backups,
	compress    => $Conf{CompressLevel},
	XferMethod  => $Conf{XferMethod},
	pidHandler  => \&pidHandler,
    });

    if ( !defined($logMsg = $xfer->start()) ) {
        print(LOG $bpc->timeStamp, "xfer start failed: ", $xfer->errStr, "\n");
        print("dump failed: ", $xfer->errStr, "\n");
        print("link $clientURI\n") if ( $needLink );
        #
        # kill off the tar process, first nicely then forcefully
        #
	if ( $tarPid > 0 ) {
	    kill(2, $tarPid);
	    sleep(1);
	    kill(9, $tarPid);
	}
	if ( @xferPid ) {
	    kill(2, @xferPid);
	    sleep(1);
	    kill(9, @xferPid);
	}
	UserCommandRun("DumpPostUserCmd") if ( $NeedPostCmd );
        exit(1);
    }

    @xferPid = $xfer->xferPid;

    if ( $useTar ) {
	#
	# The parent must close both handles on the pipe since the children
	# are using these handles now.
	#
	close(RH);
	close(WH);
    }
    print(LOG $bpc->timeStamp, $logMsg, "\n");
    print("started $type dump, share=$shareName\n");

    pidHandler(@xferPid);

    if ( $useTar ) {
	#
	# Parse the output of the transfer program and BackupPC_tarExtract
	# while they run.  Since we might be reading from two or more children
	# we use a select.
	#
	my($FDread, $tarOut, $mesg);
	vec($FDread, fileno(TAR), 1) = 1 if ( $useTar );
	$xfer->setSelectMask(\$FDread);

	SCAN: while ( 1 ) {
	    my $ein = $FDread;
	    last if ( $FDread =~ /^\0*$/ );
	    select(my $rout = $FDread, undef, $ein, undef);
	    if ( $useTar ) {
		if ( vec($rout, fileno(TAR), 1) ) {
		    if ( sysread(TAR, $mesg, 8192) <= 0 ) {
			vec($FDread, fileno(TAR), 1) = 0;
			close(TAR);
		    } else {
			$tarOut .= $mesg;
		    }
		}
		while ( $tarOut =~ /(.*?)[\n\r]+(.*)/s ) {
		    $_ = $1;
		    $tarOut = $2;
		    $XferLOG->write(\"tarExtract: $_\n");
		    if ( /^Done: (\d+) errors, (\d+) filesExist, (\d+) sizeExist, (\d+) sizeExistComp, (\d+) filesTotal, (\d+) sizeTotal/ ) {
			$tarErrs       += $1;
			$nFilesExist   += $2;
			$sizeExist     += $3;
			$sizeExistComp += $4;
			$nFilesTotal   += $5;
			$sizeTotal     += $6;
		    }
		}
	    }
	    last if ( !$xfer->readOutput(\$FDread, $rout) );
	    while ( my $str = $xfer->logMsgGet ) {
		print(LOG $bpc->timeStamp, "xfer: $str\n");
	    }
	    if ( $xfer->getStats->{fileCnt} == 1 ) {
		#
		# Make sure it is still the machine we expect.  We do this while
		# the transfer is running to avoid a potential race condition if
		# the ip address was reassigned by dhcp just before we started
		# the transfer.
		#
		if ( my $errMsg = CorrectHostCheck($hostIP, $host) ) {
		    $stat{hostError} = $errMsg;
		    last SCAN;
		}
	    }
	}
    } else {
	#
	# otherwise the xfer module does everything for us
	#
	my @results = $xfer->run();
	$tarErrs       += $results[0];
	$nFilesExist   += $results[1];
	$sizeExist     += $results[2];
	$sizeExistComp += $results[3];
	$nFilesTotal   += $results[4];
	$sizeTotal     += $results[5];
    }

    #
    # Merge the xfer status (need to accumulate counts)
    #
    my $newStat = $xfer->getStats;
    foreach my $k ( (keys(%stat), keys(%$newStat)) ) {
        next if ( !defined($newStat->{$k}) );
        if ( $k =~ /Cnt$/ ) {
            $stat{$k} += $newStat->{$k};
            delete($newStat->{$k});
            next;
        }
        if ( !defined($stat{$k}) ) {
            $stat{$k} = $newStat->{$k};
            delete($newStat->{$k});
            next;
        }
    }
    $stat{xferOK} = 0 if ( $stat{hostError} || $stat{hostAbort} );
    if ( !$stat{xferOK} ) {
        #
        # kill off the tranfer program, first nicely then forcefully
        #
	if ( @xferPid ) {
	    kill(2, @xferPid);
	    sleep(1);
	    kill(9, @xferPid);
	}
        #
        # kill off the tar process, first nicely then forcefully
        #
	if ( $tarPid > 0 ) {
	    kill(2, $tarPid);
	    sleep(1);
	    kill(9, $tarPid);
	}
        #
        # don't do any more shares on this host
        #
        last;
    }
}
my $lastNum  = -1;

#
# Do one last check to make sure it is still the machine we expect.
#
if ( $stat{xferOK} && (my $errMsg = CorrectHostCheck($hostIP, $host)) ) {
    $stat{hostError} = $errMsg;
    $stat{xferOK} = 0;
}

UserCommandRun("DumpPostUserCmd") if ( $NeedPostCmd );
$XferLOG->close();
close($newFilesFH) if ( defined($newFilesFH) );

if ( $stat{xferOK} ) {
    @Backups = $bpc->BackupInfoRead($client);
    for ( my $i = 0 ; $i < @Backups ; $i++ ) {
        $lastNum = $Backups[$i]{num} if ( $lastNum < $Backups[$i]{num} );
    }
    $lastNum++;
    $bpc->RmTreeDefer("$TopDir/trash", "$Dir/$lastNum")
                                if ( -d "$Dir/$lastNum" );
    if ( !rename("$Dir/new", "$Dir/$lastNum") ) {
        print(LOG $bpc->timeStamp,
                  "Rename $Dir/new -> $Dir/$lastNum failed\n");
        $stat{xferOK} = 0;
    }
    rename("$Dir/XferLOG$fileExt", "$Dir/XferLOG.$lastNum$fileExt");
    rename("$Dir/NewFileList", "$Dir/NewFileList.$lastNum");
}
my $endTime = time();

#
# If the dump failed, clean up
#
if ( !$stat{xferOK} ) {
    #
    # wait a short while and see if the system is still alive
    #
    $stat{hostError} = $stat{lastOutputLine} if ( $stat{hostError} eq "" );
    if ( $stat{hostError} ) {
        print(LOG $bpc->timeStamp,
                  "Got fatal error during xfer ($stat{hostError})\n");
    }
    sleep(10);
    if ( $bpc->CheckHostAlive($hostIP) < 0 ) {
        $stat{hostAbort} = 1;
    }
    if ( $stat{hostAbort} ) {
        $stat{hostError} = "lost network connection during backup";
    }
    print(LOG $bpc->timeStamp, "Dump aborted ($stat{hostError})\n");
    unlink("$Dir/timeStamp.level0");
    unlink("$Dir/SmbLOG.bad");
    unlink("$Dir/SmbLOG.bad$fileExt");
    unlink("$Dir/XferLOG.bad");
    unlink("$Dir/XferLOG.bad$fileExt");
    unlink("$Dir/NewFileList");
    rename("$Dir/XferLOG$fileExt", "$Dir/XferLOG.bad$fileExt");
    $bpc->RmTreeDefer("$TopDir/trash", "$Dir/new") if ( -d "$Dir/new" );
    print("dump failed: $stat{hostError}\n");
    print("link $clientURI\n") if ( $needLink );
    exit(1);
}

#
# Add the new backup information to the backup file
#
@Backups = $bpc->BackupInfoRead($client);
my $i = @Backups;
$Backups[$i]{num}           = $lastNum;
$Backups[$i]{type}          = $type;
$Backups[$i]{startTime}     = $startTime;
$Backups[$i]{endTime}       = $endTime;
$Backups[$i]{size}          = $sizeTotal;
$Backups[$i]{nFiles}        = $nFilesTotal;
$Backups[$i]{xferErrs}      = $stat{xferErrCnt} || 0;
$Backups[$i]{xferBadFile}   = $stat{xferBadFileCnt} || 0;
$Backups[$i]{xferBadShare}  = $stat{xferBadShareCnt} || 0;
$Backups[$i]{nFilesExist}   = $nFilesExist;
$Backups[$i]{sizeExist}     = $sizeExist;
$Backups[$i]{sizeExistComp} = $sizeExistComp;
$Backups[$i]{tarErrs}       = $tarErrs;
$Backups[$i]{compress}      = $Conf{CompressLevel};
$Backups[$i]{noFill}        = $type eq "full" ? 0 : 1;
$Backups[$i]{mangle}        = 1;        # name mangling always on for v1.04+
$bpc->BackupInfoWrite($client, @Backups);

unlink("$Dir/timeStamp.level0");

#
# Now remove the bad files, replacing them if possible with links to
# earlier backups.
#
foreach my $file ( $xfer->getBadFiles ) {
    my $j;
    unlink("$Dir/$lastNum/$file");
    for ( $j = $i - 1 ; $j >= 0 ; $j-- ) {
        next if ( !-f "$Dir/$Backups[$j]{num}/$file" );
        if ( !link("$Dir/$Backups[$j]{num}/$file", "$Dir/$lastNum/$file") ) {
            print(LOG $bpc->timeStamp,
                      "Unable to link $lastNum/$file to"
                    . " $Backups[$j]{num}/$file\n");
        } else {
            print(LOG $bpc->timeStamp,
                      "Bad file $lastNum/$file replaced by link to"
                    . " $Backups[$j]{num}/$file\n");
        }
        last;
    }
    if ( $j < 0 ) {
        print(LOG $bpc->timeStamp,
                  "Removed bad file $lastNum/$file (no older"
                . " copy to link to)\n");
    }
}

my $otherCount = $stat{xferErrCnt} - $stat{xferBadFileCnt}
                                   - $stat{xferBadShareCnt};
print(LOG $bpc->timeStamp,
          "$type backup $lastNum complete, $stat{fileCnt} files,"
        . " $stat{byteCnt} bytes,"
        . " $stat{xferErrCnt} xferErrs ($stat{xferBadFileCnt} bad files,"
        . " $stat{xferBadShareCnt} bad shares, $otherCount other)\n");

BackupExpire($client);

print("$type backup complete\n");

###########################################################################
# Subroutines
###########################################################################

sub NothingToDo
{
    my($needLink) = @_;

    print("nothing to do\n");
    print("link $clientURI\n") if ( $needLink );
    exit(0);
}

sub catch_signal
{
    my $signame = shift;
    my $fileExt = $Conf{CompressLevel} > 0 ? ".z" : "";

    #
    # Ignore signals in children
    #
    return if ( $Pid != $$ );

    print(LOG $bpc->timeStamp, "cleaning up after signal $signame\n");
    $SIG{$signame} = 'IGNORE';
    UserCommandRun("DumpPostUserCmd") if ( $NeedPostCmd );
    $XferLOG->write(\"exiting after signal $signame\n");
    $XferLOG->close();
    if ( @xferPid ) {
        kill(2, @xferPid);
	sleep(1);
	kill(9, @xferPid);
    }
    if ( $tarPid > 0 ) {
        kill(2, $tarPid);
	sleep(1);
	kill(9, $tarPid);
    }
    unlink("$Dir/timeStamp.level0");
    unlink("$Dir/NewFileList");
    unlink("$Dir/XferLOG.bad");
    unlink("$Dir/XferLOG.bad$fileExt");
    rename("$Dir/XferLOG$fileExt", "$Dir/XferLOG.bad$fileExt");
    $bpc->RmTreeDefer("$TopDir/trash", "$Dir/new") if ( -d "$Dir/new" );
    if ( $signame eq "INT" ) {
        print("dump failed: aborted by user (signal=$signame)\n");
    } else {
        print("dump failed: received signal=$signame\n");
    }
    print("link $clientURI\n") if ( $needLink );
    exit(1);
}

#
# Decide which old backups should be expired by moving them
# to $TopDir/trash.
#
sub BackupExpire
{
    my($client) = @_;
    my($Dir) = "$TopDir/pc/$client";
    my(@Backups) = $bpc->BackupInfoRead($client);
    my($cntFull, $cntIncr, $firstFull, $firstIncr, $oldestIncr, $oldestFull);

    while ( 1 ) {
	$cntFull = $cntIncr = 0;
	$oldestIncr = $oldestFull = 0;
	for ( $i = 0 ; $i < @Backups ; $i++ ) {
	    if ( $Backups[$i]{type} eq "full" ) {
		$firstFull = $i if ( $cntFull == 0 );
		$cntFull++;
	    } else {
		$firstIncr = $i if ( $cntIncr == 0 );
		$cntIncr++;
	    }
	}
	$oldestIncr = (time - $Backups[$firstIncr]{startTime}) / (24 * 3600)
                        if ( $cntIncr > 0 );
	$oldestFull = (time - $Backups[$firstFull]{startTime}) / (24 * 3600)
                        if ( $cntFull > 0 );
	if ( $cntIncr > $Conf{IncrKeepCnt}
		|| ($cntIncr > $Conf{IncrKeepCntMin}
		    && $oldestIncr > $Conf{IncrAgeMax})
               && (@Backups <= $firstIncr + 1
                        || $Backups[$firstIncr]{noFill}
                        || !$Backups[$firstIncr + 1]{noFill}) ) {
            #
            # Only delete an incr backup if the Conf settings are satisfied.
            # We also must make sure that either this backup is the most
            # recent one, or it is not filled, or the next backup is filled.
            # (We can't deleted a filled incr if the next backup is not
            # filled.)
            # 
	    print(LOG $bpc->timeStamp,
                      "removing incr backup $Backups[$firstIncr]{num}\n");
	    $bpc->RmTreeDefer("$TopDir/trash",
                              "$Dir/$Backups[$firstIncr]{num}");
	    unlink("$Dir/SmbLOG.$Backups[$firstIncr]{num}")
                        if ( -f "$Dir/SmbLOG.$Backups[$firstIncr]{num}" );
	    unlink("$Dir/SmbLOG.$Backups[$firstIncr]{num}.z")
                        if ( -f "$Dir/SmbLOG.$Backups[$firstIncr]{num}.z" );
	    unlink("$Dir/XferLOG.$Backups[$firstIncr]{num}")
                        if ( -f "$Dir/XferLOG.$Backups[$firstIncr]{num}" );
	    unlink("$Dir/XferLOG.$Backups[$firstIncr]{num}.z")
                        if ( -f "$Dir/XferLOG.$Backups[$firstIncr]{num}.z" );
	    splice(@Backups, $firstIncr, 1);
	} elsif ( ($cntFull > $Conf{FullKeepCnt}
                    || ($cntFull > $Conf{FullKeepCntMin}
                        && $oldestFull > $Conf{FullAgeMax}))
               && (@Backups <= $firstFull + 1
                        || !$Backups[$firstFull + 1]{noFill}) ) {
            #
            # Only delete a full backup if the Conf settings are satisfied.
            # We also must make sure that either this backup is the most
            # recent one, or the next backup is filled.
            # (We can't deleted a full backup if the next backup is not
            # filled.)
            # 
	    print(LOG $bpc->timeStamp,
                   "removing full backup $Backups[$firstFull]{num}\n");
	    $bpc->RmTreeDefer("$TopDir/trash",
                              "$Dir/$Backups[$firstFull]{num}");
	    unlink("$Dir/SmbLOG.$Backups[$firstFull]{num}")
                        if ( -f "$Dir/SmbLOG.$Backups[$firstFull]{num}" );
	    unlink("$Dir/SmbLOG.$Backups[$firstFull]{num}.z")
                        if ( -f "$Dir/SmbLOG.$Backups[$firstFull]{num}.z" );
	    unlink("$Dir/XferLOG.$Backups[$firstFull]{num}")
                        if ( -f "$Dir/XferLOG.$Backups[$firstFull]{num}" );
	    unlink("$Dir/XferLOG.$Backups[$firstFull]{num}.z")
                        if ( -f "$Dir/XferLOG.$Backups[$firstFull]{num}.z" );
	    splice(@Backups, $firstFull, 1);
	} else {
	    last;
	}
    }
    $bpc->BackupInfoWrite($client, @Backups);
}

sub CorrectHostCheck
{
    my($hostIP, $host) = @_;
    return if ( $hostIP eq $host && !$Conf{FixedIPNetBiosNameCheck}
		|| $Conf{NmbLookupCmd} eq "" );
    my($netBiosHost, $netBiosUser) = $bpc->NetBiosInfoGet($hostIP);
    return "host $host has mismatching netbios name $netBiosHost"
		if ( $netBiosHost ne $host );
    return;
}

#
# The Xfer method might tell us from time to time about processes
# it forks.  We tell BackupPC about this (for status displays) and
# keep track of the pids in case we cancel the backup
#
sub pidHandler
{
    @xferPid = @_;
    @xferPid = grep(/./, @xferPid);
    return if ( !@xferPid && $tarPid < 0 );
    my @pids = @xferPid;
    push(@pids, $tarPid) if ( $tarPid > 0 );
    my $str = join(",", @pids);
    $XferLOG->write(\"Xfer PIDs are now $str\n") if ( defined($XferLOG) );
    print("xferPids $str\n");
}

#
# Run an optional pre- or post-dump command
#
sub UserCommandRun
{
    my($type) = @_;

    return if ( !defined($Conf{$type}) );
    my $vars = {
        xfer       => $xfer,
        client     => $client,
        host       => $host,
        hostIP     => $hostIP,
	user       => $Hosts->{$client}{user},
	moreUsers  => $Hosts->{$client}{moreUsers},
        share      => $ShareNames->[0],
        shares     => $ShareNames,
        XferMethod => $Conf{XferMethod},
        sshPath    => $Conf{SshPath},
        LOG        => *LOG,
        XferLOG    => $XferLOG,
        stat       => \%stat,
        xferOK     => $stat{xferOK},
	type	   => $type,
    };
    my $cmd = $bpc->cmdVarSubstitute($Conf{$type}, $vars);
    $XferLOG->write(\"Executing $type: @$cmd\n");
    #
    # Run the user's command, dumping the stdout/stderr into the
    # Xfer log file.  Also supply the optional $vars and %Conf in
    # case the command is really perl code instead of a shell
    # command.
    #
    $bpc->cmdSystemOrEval($cmd,
	    sub {
		$XferLOG->write(\$_[0]);
	    },
	    $vars, \%Conf);
}
